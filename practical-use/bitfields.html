<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C-Style Bitfields - A User’s Guide to the &#x60;bitvec&#x60; Project</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A more thorough manual of the &#x60;bitvec&#x60; project">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../dedication.html">Dedication</a></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../data-structures.html"><strong aria-hidden="true">2.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../data-structures/bitslice.html"><strong aria-hidden="true">2.1.</strong> BitSlice</a></li><li class="chapter-item expanded "><a href="../data-structures/bitarray.html"><strong aria-hidden="true">2.2.</strong> BitArray</a></li><li class="chapter-item expanded "><a href="../data-structures/bitvec.html"><strong aria-hidden="true">2.3.</strong> BitVec and BitBox</a></li></ol></li><li class="chapter-item expanded "><a href="../type-parameters.html"><strong aria-hidden="true">3.</strong> Type Parameters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-parameters/bitorder.html"><strong aria-hidden="true">3.1.</strong> BitOrder</a></li><li class="chapter-item expanded "><a href="../type-parameters/bitstore.html"><strong aria-hidden="true">3.2.</strong> BitStore</a></li></ol></li><li class="chapter-item expanded "><a href="../practical-use.html"><strong aria-hidden="true">4.</strong> Practical Use</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../practical-use/collections.html"><strong aria-hidden="true">4.1.</strong> bool Collections</a></li><li class="chapter-item expanded "><a href="../practical-use/bitfields.html" class="active"><strong aria-hidden="true">4.2.</strong> C-Style Bitfields</a></li></ol></li><li class="chapter-item expanded "><a href="../memory-model.html"><strong aria-hidden="true">5.</strong> Memory Model</a></li><li class="chapter-item expanded "><a href="../pointer-encoding.html"><strong aria-hidden="true">6.</strong> Pointer Encoding</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A User’s Guide to the &#x60;bitvec&#x60; Project</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bitfields"><a class="header" href="#bitfields">Bitfields</a></h1>
<p><code>bitvec</code>’s more technically-interesting capability is that it provides
load/store memory access behaviors that allow you to write values into, and read
them back out of, any <code>BitSlice</code> in memory rather than being constrained to
well-formed references to well-typed memory.</p>
<p>This is useful for the de/construction of packed memory buffers, such as
transporting data through I/O protocols.</p>
<p>All of this behavior is contained in the <code>BitField</code> trait. Let’s explore that:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//  bitvec::field

pub trait BitField {
  fn load&lt;M&gt;(&amp;self) -&gt; M;
  fn store&lt;M&gt;(&amp;mut self, value: M);
}

impl&lt;T&gt; BitField for BitSlice&lt;Lsb0, T&gt; {
  fn load&lt;M&gt;(&amp;self) -&gt; M { /**/ }
  fn store&lt;M&gt;(&amp;mut self, value: M) { /**/ }
}

impl&lt;T&gt; BitField for BitSlice&lt;Msb0, T&gt; {
  fn load&lt;M&gt;(&amp;self) -&gt; M { /**/ }
  fn store&lt;M&gt;(&amp;mut self, value: M) { /**/ }
}
<span class="boring">}
</span></code></pre></pre>
<p>The actual trait is more complex than this, and will be visited later. The
important part, right now, is that <code>BitField</code> allows you to load values out of
<code>BitSlice</code>s and store values into them. Furthermore, it is implemented
<em>specifically</em> on <code>BitSlices</code> that use the bit orderings provided by <code>bitvec</code>,
and is <strong>not</strong> generic over all orderings.</p>
<p>While <code>bitvec</code> could in theory provide a default implementation for all
<code>&lt;O: BitOrder&gt;</code>, this would by necessity have the most pessimal possible
performance, and the lack of specialization for overlapping trait
implementations means that faster performance can never be written.</p>
<p>The downside of the two specific implementations is that Rust <em>coherence</em> rules
forbid implementation of a <code>bitvec</code> trait, on a <code>bitvec</code> type, parameterized
with a local, but non-<code>bitvec</code>, ordering type. On the off chance that you find
yourself writing a new <code>BitOrder</code> implementor, file an issue.</p>
<p>The <code>M</code> type parameter on the load and store methods is bounded by <code>BitMemory</code>,
which essentially means “is an unsigned integer”, with some extra bookkeeping
information used by <code>bitvec</code> internals. This parameterization allows you to
combine any integer type for transfer with any integer type for storage, rather
than being restricted to only transferring, <code>T</code> data into and out of a
<code>BitSlice&lt;_, T&gt;</code>.</p>
<p>Unfortunately, adding a second integer type parameter is not the only
complication to the <code>BitStore</code> memory model. There is also a second dimension of
segment ordering. <code>bitvec</code> tries to make explicitly clear that the <code>Lsb0</code> and
<code>Msb0</code> types refer only to the ordering of <em>bits</em> within registers, and not to
the ordering of <em>bytes</em> within registers. However, when the register being
stored or stored does not fit within one register of the storage <code>BitSlice</code>, it
must be split into multiple segments, and those segments must somehow be ordered
in memory.</p>
<h2 id="segment-orderings"><a class="header" href="#segment-orderings">Segment Orderings</a></h2>
<p>There are two segment orderings: little-endian and big-endian. You may select
the segment endianness you prefer by using the <code>_le</code> or <code>_be</code> suffix,
respectively, on the <code>.load</code> and <code>.store</code> methods. The unsuffixed method is an
alias for the endianness of your processor: <code>_be</code> on big-endian targets, and
<code>_le</code> on little-endian.</p>
<p>Let us imagine a <code>BitSlice&lt;Lsb0, u8&gt;</code> used to store a <code>u16</code> that is misaligned,
and thus stored in two successive bytes. This algorithm is true for all
circumstances where the stored region occupies more than one register of the
backing slice, but smaller examples are simpler to draw.</p>
<p>This diagram uses <code>0</code> to refer to the least significant bit, and <code>7</code> to refer to
the most significant bit. The first row shows bytes of memory, the second row
shows the bit indices in memory used by <code>.store_le</code>, and the third row shows the
bit indices in memory used by <code>.store_be</code>.</p>
<pre><code class="language-text">[ 7 6 5 4 3 2 1 0 ] [ 7 6 5 4 3 2 1 0 ] [ 7 6 5 4 3 2 1 0 ]
  3 2 1 0             b a 9 8 7 6 5 4             f e d c
  f e d c             b a 9 8 7 6 5 4             3 2 1 0
</code></pre>
<p><code>.store_le</code> places the least significant segment in the low address, while
<code>.store_be</code> places the most significant segment in the low address. The ordering
of bits within a segment is <em>always</em> preserved, no matter which ordering
parameter is used by the <code>BitSlice</code>.</p>
<p>Here is the same example, but using the <code>Msb0</code> bit ordering instead. Again, the
second row uses <code>.store_le</code>, and the third row uses <code>.store_be</code>.</p>
<pre><code class="language-text">[ 7 6 5 4 3 2 1 0 ] [ 7 6 5 4 3 2 1 0 ] [ 7 6 5 4 3 2 1 0 ]
          3 2 1 0     b a 9 8 7 6 5 4     f e d c
          f e d c     b a 9 8 7 6 5 4     3 2 1 0
</code></pre>
<p>The only change is in how the segments are placed into memory. The ordering of
bits within a segment never changes, and is always the processor’s significance
order as implemented in hardware.</p>
<h2 id="how-to-use-bitfield"><a class="header" href="#how-to-use-bitfield">How to Use <code>BitField</code></a></h2>
<p>You will probably find real use of the <code>BitField</code> trait more educational than
the previous section. It has a very straightforward API, that you can combine
with <code>println!</code>-debugging or your favorite means of viewing memory in order to
observe its actions.</p>
<p>Step one: create any <code>BitSlice</code>-capable buffer. This can be any of the
Rust-native sequence types, or any of the <code>bitvec</code> types.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bitvec::prelude::*;

let mut data = [0u8; 4];
let bits = data.view_bits_mut::&lt;Msb0&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>Then, narrow the <code>BitSlice</code> to be the region you want to access as storage. It
must be no wider than the integer type you are transferring: <code>BitSlice</code>s outside
the domain <code>1 ..= M::BITS</code> will panic during <code>.load</code> or <code>.store</code>. The easiest
way to narrow a <code>BitSlice</code> (or buffer type that dereferences to it) is by using
range indexing, <code>[start .. end]</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bitvec::prelude::*;
</span><span class="boring">let bits = bits![mut Msb0, u8; 0; 32];
</span>bits[10 ..][.. 13].store_be::&lt;u16&gt;(0x765);
assert_eq!(bits[10 .. 23].load_be::&lt;u16&gt;(), 0x765);

bits[10 .. 23].store_le::&lt;u16&gt;(0x432);
assert_eq!(bits[10 .. 23].load_le::&lt;u16&gt;(), 0x432);
<span class="boring">}
</span></code></pre></pre>
<p>That’s the entire API. <code>.store</code> truncates the stored value to the width of the
receiving <code>BitSlice</code>, and <code>.load</code> zero-extends the loaded value to the width of
the destination register type.</p>
<blockquote>
<p>If you want the ability to transfer signed integers, including signed
truncation during <code>.store</code> and sign-extension during <code>.load</code>, please file an
issue.</p>
</blockquote>
<p>You can see an example that uses the <code>BitField</code> trait to implement an I/O
protocol in the <code>examples/ipv4.rs</code> program in the repository. Use
<code>cargo run --example ipv4</code> to see it in action.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../practical-use/collections.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../memory-model.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../practical-use/collections.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../memory-model.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
